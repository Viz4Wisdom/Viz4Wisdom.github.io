<!DOCTYPE html>
<head>
  <meta charset="utf-8">
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/d3-color.v1.min.js"></script>
  <script src="https://d3js.org/d3-interpolate.v1.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>

  <link rel="stylesheet" type="text/css" href="style.css"></style>
</head>

<body>
  <script>
    // Helper functions
    function set_svg_size(svg_elem, c_width, c_height) {
      // Takes sizes as an input, and returns the two sizes
      // that optimizes a 19:9 ratio
      adapted_w = c_height * 16 / 9
      adapted_h = c_width * 9 / 16

      console.log(c_width, c_height, adapted_h, adapted_w)

      if (adapted_h > c_height) {
        svg_elem
            .attr("width", adapted_w)
            .attr("height", c_height)
      } else {
        svg_elem
            .attr("width", c_width)
            .attr("height", adapted_h)
      }
    }

    function define_points(packet_ref, ip_iter, i, proj_obj) {
      
      points = [{}, {}, {}]
      ip_iter.forEach(function(ip_refs) {
        if (ip_refs.ip == packet_ref.Sender) {
          if (ip_refs.longitude == undefined || ip_refs.latitude == undefined) {
            points[0] = {x: 0, y: 0}
          } else {
            coords = projection([+ip_refs.longitude, +ip_refs.latitude])
            points[0] = {x: coords[0], y: coords[1]}
          }
        } else if (ip_refs.ip == packet_ref.Receiver) {
          if (ip_refs.longitude == undefined || ip_refs.latitude == undefined) {
            points[2] = {x: 0, y: 0}
          } else {
            coords = projection([+ip_refs.longitude, +ip_refs.latitude])
            points[2] = {x: coords[0], y: coords[1]}
          }
        }
      })

      points[1] = {x: (points[0].x + points[2].x) / 2, y: (points[0].y + points[2].y) / 2 - Math.abs(points[0].x - points[2].x)/6}

      packet_ref.points = points
    }
    
    function add_geolocation_to_packet_json(p_iter, ip_iter) {

      nb_packets = p_iter.length
      current_prog = 0
      
      p_iter.forEach(function (packet, i) {

        define_points(packet, ip_iter, i)
        
        // Plotting the data binding progess
        if((10 * i / nb_packets) > current_prog ) {
          console.log(10*current_prog + " - " + (10 * ++current_prog) + "%") 
        }
      

      })
    }

    function arc_generator(x1, y1, x2, y2, radius) {

      x_m = (x1 + x2) / 2
      y_m = (y1 + y2) / 2

      dxy = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

      x_r = x_m - (x2 - x1)/dxy * radius
      y_r = y_m - (y2 - y1)/dxy * radius

      alpha = Math.asin((y2-y1)/dxy)
      beta = Math.atan(dxy/2/radius)

      arc = d3.arc()
        .outerRadius(radius + 0.1)
        .innerRadius(radius)
        .startAngle(alpha + beta)
        .endAngle(alpha - beta)

    }

    // ****************************
    // * Constants initialization *
    // ****************************
    var client_w = document.documentElement.clientWidth,
        client_h = document.documentElement.clientHeight,
        map_w = client_w, map_h = client_h;


    // Creating the canvas
		var global_cont = d3.select( "body" )
        .append("div")
        .attr("id", "global_container")
  	
    var svg = global_cont.append( "svg" )

    set_svg_size(svg, map_w, map_h)

    var projection = d3.geoNaturalEarth1()
        .center([2.454071, 46.279229]) // Centering on France
        .scale(200);

    var path = d3.geoPath() // d3.geo.path avec d3 version 3
         .projection(projection);

  d3.json("world_topography_50.json", function(geojson_elem) {
      svg.selectAll("path")
        .data(geojson_elem.features)
        .enter()
        .append("path")
        .attr("d", path)
    })

    // Creating the tooltip object
    var tooltip = global_cont.append('div')
      .attr('class', 'hidden tooltip');


    var curve_obj = d3.curveBundle.beta(0.5)

    var line_obj = d3.line()
      .x(d => d.x)
      .y(d => d.y)
      .curve(d3.curveBundle.beta(0.5))   

    var base_beta = 0.5

    function gaussian_generator() {
      u1 = Math.random()
      u2 = Math.random()

      R = Math.sqrt(-2 * Math.log(u1))
      theta = 2 * Math.PI * u2

      return R*Math.sin(theta) / 3
    }

    // *********************
    // * Readers functions *
    // *********************

    // Opening the packets json
    d3.json("packets_data.json", function(packets_iterator) {
      
      // Opening the IPs json
      d3.json("ip_reference_data.json", function(ips_iterator) {

        add_geolocation_to_packet_json(packets_iterator, ips_iterator)

        svg.append("g").selectAll("path")
          .data(packets_iterator)
          .enter()
          .append("path")
          .attr("class", "stream")
          .attr("path", path)
          .transition()
          .duration(1)
          .delay(function(d, i) { return 0.1*i;})
          .attr("d", function(d) { line_obj.curve(d3.curveBundle.beta(base_beta + 2*gaussian_generator()/10)) ; return line_obj(d.points) })
          

      }) // Closing the IPs json

    }) // Closing the packets json


  </script>

</body>

